jest.mock('uuid', () => ({
  v4: jest.fn(() => `mock-uuid-${Math.random().toString(36).substring(2, 10)}`),
}));

import { CorrelationIdMiddleware } from '../middleware/correlation-id.middleware';
import { loggingContext } from '../logging.context';
import { Request, Response, NextFunction } from 'express';

describe('CorrelationIdMiddleware', () => {
  let middleware: CorrelationIdMiddleware;

  beforeEach(() => {
    middleware = new CorrelationIdMiddleware();
  });

  function createMockRequest(headers: Record<string, string> = {}): Partial<Request> {
    return {
      headers: { ...headers },
    };
  }

  function createMockResponse(): Partial<Response> {
    const res: Partial<Response> = {
      setHeader: jest.fn().mockReturnThis(),
    };
    return res;
  }

  it('should generate UUID v4 trace ID for requests without one', (done) => {
    const req = createMockRequest();
    const res = createMockResponse();
    const next: NextFunction = () => {
      const store = loggingContext.getStore();
      expect(store).toBeDefined();
      expect(store!.traceId).toBeDefined();
      // Should be a non-empty string (generated by uuid.v4)
      expect(typeof store!.traceId).toBe('string');
      expect(store!.traceId.length).toBeGreaterThan(0);
      done();
    };

    middleware.use(req as Request, res as Response, next);
  });

  it('should use incoming x-trace-id header when present', (done) => {
    const req = createMockRequest({ 'x-trace-id': 'existing-trace-id' });
    const res = createMockResponse();
    const next: NextFunction = () => {
      const store = loggingContext.getStore();
      expect(store!.traceId).toBe('existing-trace-id');
      done();
    };

    middleware.use(req as Request, res as Response, next);
  });

  it('should use incoming x-correlation-id header when present', (done) => {
    const req = createMockRequest({ 'x-correlation-id': 'correlation-id-value' });
    const res = createMockResponse();
    const next: NextFunction = () => {
      const store = loggingContext.getStore();
      expect(store!.traceId).toBe('correlation-id-value');
      done();
    };

    middleware.use(req as Request, res as Response, next);
  });

  it('should attach x-trace-id to response headers', (done) => {
    const req = createMockRequest({ 'x-trace-id': 'response-trace' });
    const res = createMockResponse();
    const next: NextFunction = () => {
      expect(res.setHeader).toHaveBeenCalledWith('x-trace-id', 'response-trace');
      done();
    };

    middleware.use(req as Request, res as Response, next);
  });

  it('should store trace ID in AsyncLocalStorage context', (done) => {
    const req = createMockRequest({ 'x-trace-id': 'als-test-trace' });
    const res = createMockResponse();
    const next: NextFunction = () => {
      const store = loggingContext.getStore();
      expect(store).toBeDefined();
      expect(store!.traceId).toBe('als-test-trace');
      done();
    };

    middleware.use(req as Request, res as Response, next);
  });

  it('should generate unique trace IDs for concurrent requests', (done) => {
    const traceIds: string[] = [];
    let completed = 0;
    const total = 5;

    for (let i = 0; i < total; i++) {
      const req = createMockRequest();
      const res = createMockResponse();
      const next: NextFunction = () => {
        const store = loggingContext.getStore();
        traceIds.push(store!.traceId);
        completed++;
        if (completed === total) {
          // All trace IDs should be unique
          const uniqueIds = new Set(traceIds);
          expect(uniqueIds.size).toBe(total);
          done();
        }
      };

      middleware.use(req as Request, res as Response, next);
    }
  });

  it('should prefer x-trace-id over x-correlation-id when both present', (done) => {
    const req = createMockRequest({
      'x-trace-id': 'trace-wins',
      'x-correlation-id': 'correlation-loses',
    });
    const res = createMockResponse();
    const next: NextFunction = () => {
      const store = loggingContext.getStore();
      expect(store!.traceId).toBe('trace-wins');
      done();
    };

    middleware.use(req as Request, res as Response, next);
  });
});
